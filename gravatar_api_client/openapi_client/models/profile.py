# coding: utf-8

"""
    Gravatar Public API

    Gravatar's public API endpoints

    The version of the OpenAPI document: 3.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, field_validator, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.gallery_image import GalleryImage
from openapi_client.models.interest import Interest
from openapi_client.models.language import Language
from openapi_client.models.link import Link
from openapi_client.models.profile_contact_info import ProfileContactInfo
from openapi_client.models.profile_payments import ProfilePayments
from openapi_client.models.verified_account import VerifiedAccount
from typing import Optional, Set
from typing_extensions import Self

class Profile(BaseModel):
    """
    A user's profile information.
    """ # noqa: E501
    hash: StrictStr = Field(description="The SHA256 hash of the user's primary email address.")
    display_name: StrictStr = Field(description="The user's display name. This is the name that is displayed on their profile.")
    profile_url: StrictStr = Field(description="The full URL for the user's profile.")
    avatar_url: StrictStr = Field(description="The URL for the user's avatar image if it has been set.")
    avatar_alt_text: StrictStr = Field(description="The alt text for the user's avatar image if it has been set.")
    location: StrictStr = Field(description="The user's location.")
    description: StrictStr = Field(description="The about section on a user's profile.")
    job_title: StrictStr = Field(description="The user's job title.")
    company: StrictStr = Field(description="The user's current company's name.")
    verified_accounts: List[VerifiedAccount] = Field(description="A list of verified accounts the user has added to their profile. This is limited to a max of 4 in unauthenticated requests.")
    pronunciation: StrictStr = Field(description="The phonetic pronunciation of the user's name.")
    pronouns: StrictStr = Field(description="The pronouns the user uses.")
    timezone: Optional[StrictStr] = Field(default=None, description="The timezone the user has. This is only provided in authenticated API requests.")
    languages: Optional[List[Language]] = Field(default=None, description="The languages the user knows. This is only provided in authenticated API requests.")
    first_name: Optional[StrictStr] = Field(default=None, description="User's first name. This is only provided in authenticated API requests.")
    last_name: Optional[StrictStr] = Field(default=None, description="User's last name. This is only provided in authenticated API requests.")
    is_organization: Optional[StrictBool] = Field(default=None, description="Whether user is an organization. This is only provided in authenticated API requests.")
    header_image: Optional[StrictStr] = Field(default=None, description="The header image used in the main profile card.")
    background_color: Optional[StrictStr] = Field(default=None, description="The profile background color.")
    links: Optional[List[Link]] = Field(default=None, description="A list of links the user has added to their profile. This is only provided in authenticated API requests.")
    interests: Optional[List[Interest]] = Field(default=None, description="A list of interests the user has added to their profile. This is only provided in authenticated API requests.")
    payments: Optional[ProfilePayments] = None
    contact_info: Optional[ProfileContactInfo] = None
    gallery: Optional[List[GalleryImage]] = Field(default=None, description="Additional images a user has uploaded. This is only provided in authenticated API requests.")
    number_verified_accounts: Optional[StrictInt] = Field(default=None, description="The number of verified accounts the user has added to their profile. This count includes verified accounts the user is hiding from their profile. This is only provided in authenticated API requests.")
    last_profile_edit: Optional[datetime] = Field(default=None, description="The date and time (UTC) the user last edited their profile. This is only provided in authenticated API requests.")
    registration_date: Optional[datetime] = Field(default=None, description="The date the user registered their account. This is only provided in authenticated API requests.")
    __properties: ClassVar[List[str]] = ["hash", "display_name", "profile_url", "avatar_url", "avatar_alt_text", "location", "description", "job_title", "company", "verified_accounts", "pronunciation", "pronouns", "timezone", "languages", "first_name", "last_name", "is_organization", "header_image", "background_color", "links", "interests", "payments", "contact_info", "gallery", "number_verified_accounts", "last_profile_edit", "registration_date"]

    @field_validator('last_profile_edit')
    def last_profile_edit_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$", value):
            raise ValueError(r"must validate the regular expression /^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$/")
        return value

    @field_validator('registration_date')
    def registration_date_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$", value):
            raise ValueError(r"must validate the regular expression /^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Profile from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in verified_accounts (list)
        _items = []
        if self.verified_accounts:
            for _item_verified_accounts in self.verified_accounts:
                if _item_verified_accounts:
                    _items.append(_item_verified_accounts.to_dict())
            _dict['verified_accounts'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in languages (list)
        _items = []
        if self.languages:
            for _item_languages in self.languages:
                if _item_languages:
                    _items.append(_item_languages.to_dict())
            _dict['languages'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in links (list)
        _items = []
        if self.links:
            for _item_links in self.links:
                if _item_links:
                    _items.append(_item_links.to_dict())
            _dict['links'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in interests (list)
        _items = []
        if self.interests:
            for _item_interests in self.interests:
                if _item_interests:
                    _items.append(_item_interests.to_dict())
            _dict['interests'] = _items
        # override the default output from pydantic by calling `to_dict()` of payments
        if self.payments:
            _dict['payments'] = self.payments.to_dict()
        # override the default output from pydantic by calling `to_dict()` of contact_info
        if self.contact_info:
            _dict['contact_info'] = self.contact_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in gallery (list)
        _items = []
        if self.gallery:
            for _item_gallery in self.gallery:
                if _item_gallery:
                    _items.append(_item_gallery.to_dict())
            _dict['gallery'] = _items
        # set to None if last_profile_edit (nullable) is None
        # and model_fields_set contains the field
        if self.last_profile_edit is None and "last_profile_edit" in self.model_fields_set:
            _dict['last_profile_edit'] = None

        # set to None if registration_date (nullable) is None
        # and model_fields_set contains the field
        if self.registration_date is None and "registration_date" in self.model_fields_set:
            _dict['registration_date'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Profile from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "hash": obj.get("hash"),
            "display_name": obj.get("display_name"),
            "profile_url": obj.get("profile_url"),
            "avatar_url": obj.get("avatar_url"),
            "avatar_alt_text": obj.get("avatar_alt_text"),
            "location": obj.get("location"),
            "description": obj.get("description"),
            "job_title": obj.get("job_title"),
            "company": obj.get("company"),
            "verified_accounts": [VerifiedAccount.from_dict(_item) for _item in obj["verified_accounts"]] if obj.get("verified_accounts") is not None else None,
            "pronunciation": obj.get("pronunciation"),
            "pronouns": obj.get("pronouns"),
            "timezone": obj.get("timezone"),
            "languages": [Language.from_dict(_item) for _item in obj["languages"]] if obj.get("languages") is not None else None,
            "first_name": obj.get("first_name"),
            "last_name": obj.get("last_name"),
            "is_organization": obj.get("is_organization"),
            "header_image": obj.get("header_image"),
            "background_color": obj.get("background_color"),
            "links": [Link.from_dict(_item) for _item in obj["links"]] if obj.get("links") is not None else None,
            "interests": [Interest.from_dict(_item) for _item in obj["interests"]] if obj.get("interests") is not None else None,
            "payments": ProfilePayments.from_dict(obj["payments"]) if obj.get("payments") is not None else None,
            "contact_info": ProfileContactInfo.from_dict(obj["contact_info"]) if obj.get("contact_info") is not None else None,
            "gallery": [GalleryImage.from_dict(_item) for _item in obj["gallery"]] if obj.get("gallery") is not None else None,
            "number_verified_accounts": obj.get("number_verified_accounts"),
            "last_profile_edit": obj.get("last_profile_edit"),
            "registration_date": obj.get("registration_date")
        })
        return _obj


